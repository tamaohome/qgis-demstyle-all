# -*- coding: utf-8 -*-
"""
/***************************************************************************
 DEMStyleAllDialog
                                 A QGIS plugin
 DEMスタイル一括設定
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2026-01-26
        git sha              : $Format:%H$
        copyright            :
        email                :

 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from __future__ import annotations

import os
from pathlib import Path
from typing import override

from qgis.PyQt.QtCore import Qt
from qgis.core import Qgis
from qgis.core import QgsPointXY
from qgis.core import QgsRaster
from qgis.core import QgsMapLayerType
from qgis.core import QgsRasterLayer
from qgis.core import QgsProject
from qgis.gui import QgsMapToolEmitPoint
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtWidgets import QListWidgetItem

from .settings import DialogSettings
from .style_qml_creator import StyleQmlCreator

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), "demstyle_all_dialog_base.ui"))

DATA_RANGE_VALUES = [10, 20, 50, 100, 200, 500]


class DEMStyleAllDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, iface):
        """Constructor."""
        super(DEMStyleAllDialog, self).__init__(parent=None)
        self.iface = iface
        self.settings = DialogSettings()
        self.setupUi(self)

        self.canvas = self.iface.mapCanvas()
        self.map_tool = MouseReleaseMapTool(self.canvas)
        self.previous_map_tool = None  # 以前の地図ツールを保存

        # 初回起動時のデータレンジ値設定
        self.dataRangeSlider.setValue(2)
        self.dataRangeLineEdit.setText(str(DATA_RANGE_VALUES[2]))

        # スピンボックスの直接入力を無効化
        self.minElevationSpinBox.lineEdit().setReadOnly(True)
        self.midElevationSpinBox.lineEdit().setReadOnly(True)
        self.maxElevationSpinBox.lineEdit().setReadOnly(True)

        self.refresh_target_layer_list()  # レイヤ一覧を更新

        # シグナル接続
        self.dataRangeSlider.valueChanged.connect(self.handle_slider_change)
        self.setElevationButton.clicked.connect(self.start_capture_mode)
        self.minElevationSpinBox.valueChanged.connect(self.on_min_elevation_changed)
        self.midElevationSpinBox.valueChanged.connect(self.on_mid_elevation_changed)
        self.maxElevationSpinBox.valueChanged.connect(self.on_max_elevation_changed)
        self.map_tool.canvasClicked.connect(self.handle_get_elevation)
        self.okButton.clicked.connect(self.on_ok_clicked)
        self.cancelButton.clicked.connect(self.on_cancel_clicked)
        self.searchStringLineEdit.textChanged.connect(self.refresh_target_layer_list)

        # OKボタンの初期状態を設定
        self._update_ok_button_state()

    @override
    def showEvent(self, event):
        super().showEvent(event)

        # ダイアログ設定を復元
        self.settings.restore_dialog_state(self)

        # OKボタンへフォーカスを設定
        self.okButton.setFocus()

        # ダイアログを最前面に表示
        self.raise_()
        self.activateWindow()

    def _update_elevation_values(self, source: str) -> None:
        """標高値を更新する（source: 'min' | 'mid' | 'max'）"""
        data_range = self.get_current_data_range()

        # 値を計算
        if source == "min":
            min_value = self.minElevationSpinBox.value()
            mid_value = min_value + data_range
            max_value = mid_value + data_range
        elif source == "mid":
            mid_value = self.midElevationSpinBox.value()
            min_value = mid_value - data_range
            max_value = mid_value + data_range
        else:  # source == "max"
            max_value = self.maxElevationSpinBox.value()
            mid_value = max_value - data_range
            min_value = mid_value - data_range

        # 全てのシグナルをブロック
        self.minElevationSpinBox.blockSignals(True)
        self.midElevationSpinBox.blockSignals(True)
        self.maxElevationSpinBox.blockSignals(True)

        # 値を設定
        self.minElevationSpinBox.setValue(min_value)
        self.midElevationSpinBox.setValue(mid_value)
        self.maxElevationSpinBox.setValue(max_value)

        # シグナルのブロックを解除
        self.minElevationSpinBox.blockSignals(False)
        self.midElevationSpinBox.blockSignals(False)
        self.maxElevationSpinBox.blockSignals(False)

        self._update_ok_button_state()

    def on_min_elevation_changed(self) -> None:
        self._update_elevation_values("min")

    def on_mid_elevation_changed(self) -> None:
        self._update_elevation_values("mid")

    def on_max_elevation_changed(self) -> None:
        self._update_elevation_values("max")

    def on_ok_clicked(self):
        """OKボタン押下時の処理"""
        layers = self.get_target_layers()
        qml_creator = StyleQmlCreator(self.min_elevation, self.max_elevation)

        for layer in layers:
            # スタイルファイル (*.qml) を生成
            base_dir = Path(layer.dataProvider().dataSourceUri()).parent
            qml_filepath = qml_creator.create_style_qml_file(base_dir)

            # スタイルファイル (*.qml) をレイヤに適用
            layer.loadNamedStyle(str(qml_filepath))
            self.iface.layerTreeView().refreshLayerSymbology(layer.id())

        # メッセージバーに表示
        self.iface.messageBar().pushMessage("info", "DEMスタイルの設定が完了しました", Qgis.Info, duration=3)

        self.iface.mapCanvas().refreshAllLayers()  # 描画を更新
        self.accept()  # ダイアログを閉じる

    def on_cancel_clicked(self):
        """キャンセルボタン押下時の処理"""
        # マップツールが変更されている場合は元に戻す
        if self.previous_map_tool is not None:
            self.canvas.setMapTool(self.previous_map_tool)
        self.reject()  # ダイアログを閉じる

    def refresh_target_layer_list(self) -> None:
        """標高設定対象のレイヤ一覧を更新する"""
        self.layerListWidget.clear()  # リストを初期化

        # レイヤツリーのルートを取得
        root = QgsProject.instance().layerTreeRoot()
        # レイヤリストをツリー順で取得
        layers = [layer_node.layer() for layer_node in root.findLayers()]

        search_string = self.get_current_search_string()  # 検索文字列を取得

        for layer in layers:
            # 検索文字列に該当しないレイヤはスキップ
            if search_string not in layer.name():
                continue

            # ラスタレイヤではないレイヤはスキップ
            if layer.type() != QgsMapLayerType.RasterLayer:
                continue

            item = QListWidgetItem(layer.name())  # 表示用のアイテムを作成
            item.setData(Qt.UserRole, layer.id())  # 内部処理用にレイヤIDを保持
            self.layerListWidget.addItem(item)  # リストに追加

    def get_target_layers(self) -> list[QgsRasterLayer]:
        """標高設定対象のレイヤ配列を取得する"""
        layers = []
        for i in range(self.layerListWidget.count()):
            item = self.layerListWidget.item(i)
            layer_id = item.data(Qt.UserRole)
            layer = QgsProject.instance().mapLayer(layer_id)
            if layer is not None:
                layers.append(layer)
        return layers

    def handle_slider_change(self, index) -> None:
        """スライダーの値（インデックス）変更時の処理"""
        try:
            # リストから実数値を取得
            actual_value = DATA_RANGE_VALUES[index]
            # LineEditに文字列として反映
            self.dataRangeLineEdit.setText(str(actual_value))
            # 最小値／最大値を更新
            self.on_mid_elevation_changed()
        except IndexError:
            pass

    def get_current_data_range(self) -> int:
        """現在のデータレンジを取得する"""
        index = self.dataRangeSlider.value()
        return DATA_RANGE_VALUES[index]

    def get_current_search_string(self) -> str:
        """現在の検索文字列を取得する"""
        return self.searchStringLineEdit.text()

    def start_capture_mode(self) -> None:
        """地図キャンバス上の標高をマウスクリックで取得するモード"""
        # 現在の地図ツールを保存
        self.previous_map_tool = self.canvas.mapTool()
        self.canvas.setMapTool(self.map_tool)

    def handle_get_elevation(self, point, button) -> None:
        """標高を取得後の処理"""
        self.canvas.unsetMapTool(self.map_tool)  # ツールを解除

        # 標高取得後にダイアログを最前面に表示
        self.raise_()
        self.activateWindow()

        # 全ターゲットレイヤから標高を取得
        elevation = self.get_elevation_from_target_layers(point)

        if elevation is None:
            message = "標高値の取得に失敗しました (1)"
            QtWidgets.QMessageBox.warning(self, "エラー", message)
            return

        # 標高中心を5単位で数字丸め
        mid_elevation = round(elevation / 5) * 5

        # スピンボックスに値をセット
        self.midElevationSpinBox.setValue(mid_elevation)

        # OKボタンの状態を更新
        self._update_ok_button_state()

        # マップツールが変更されている場合は元に戻す
        if self.previous_map_tool is not None:
            self.canvas.setMapTool(self.previous_map_tool)

    @property
    def min_elevation(self) -> int:
        return self.minElevationSpinBox.value()

    @property
    def mid_elevation(self) -> int:
        return self.midElevationSpinBox.value()

    @property
    def max_elevation(self) -> int:
        return self.maxElevationSpinBox.value()

    @property
    def has_elevation(self) -> bool:
        """標高がセットされている場合 True を返す"""
        return any([self.min_elevation, self.mid_elevation, self.max_elevation])

    def _update_ok_button_state(self) -> None:
        """has_elevation の値に基づいてOKボタンの有効/無効を更新"""
        self.okButton.setEnabled(self.has_elevation)

    def _save_dialog_state(self) -> None:
        """ダイアログの設定を保存し、マップツールをリセット"""
        # マップツールが変更されている場合は元に戻す
        if self.previous_map_tool is not None:
            self.canvas.setMapTool(self.previous_map_tool)
        self.settings.save_dialog_state(self)

    @override
    def closeEvent(self, event):
        """ウィンドウを閉じる前に設定を保存"""
        self._save_dialog_state()
        event.accept()

    @override
    def reject(self):
        """ダイアログをreject時に設定を保存"""
        self._save_dialog_state()
        super().reject()

    @override
    def keyPressEvent(self, event):
        key = event.key()
        if key == Qt.Key_W:
            self.midElevationSpinBox.stepUp()
            event.accept()
        elif key == Qt.Key_S:
            self.midElevationSpinBox.stepDown()
            event.accept()
        elif key == Qt.Key_A:
            self.dataRangeSlider.setValue(
                max(self.dataRangeSlider.minimum(), self.dataRangeSlider.value() - 1)
            )
            event.accept()
        elif key == Qt.Key_D:
            self.dataRangeSlider.setValue(
                min(self.dataRangeSlider.maximum(), self.dataRangeSlider.value() + 1)
            )
            event.accept()
        else:
            super().keyPressEvent(event)

    def get_elevation_from_target_layers(self, point: QgsPointXY) -> float | None:
        """全てのターゲットレイヤから標高を取得する"""
        # ターゲットレイヤ配列を取得
        layers = self.get_target_layers()

        for layer in layers:
            # クリック地点の標高値を取得
            res = layer.dataProvider().identify(point, QgsRaster.IdentifyFormatValue)

            if not res.isValid():
                continue

            # 結果は辞書形式 {バンド番号: 値} で返される (通常、DEMは第1バンド)
            results = res.results()
            elevation = results.get(1)  # バンド1の値を取得

            if elevation is not None:
                return elevation

        # 標高値の取得に失敗した場合 None を返す
        return None


class MouseReleaseMapTool(QgsMapToolEmitPoint):
    """マウスリリースにより発火するマップツール"""

    def __init__(self, canvas):
        super().__init__(canvas)

    def canvasPressEvent(self, event):
        # マウス押下時の挙動を無効化
        pass

    def canvasReleaseEvent(self, event):
        # マウスが離された位置の地図座標を取得
        point = self.toMapCoordinates(event.pos())

        # 本来クリック時に飛ぶはずの canvasClicked シグナルを
        # リリースのタイミングで手動で発信（emit）する
        self.canvasClicked.emit(point, event.button())
